const promises = [
    fetch('./samples/BackDoor-samples.json').then(response => response.json()),
    fetch('./samples/Constructor-samples.json').then(response => response.json()),
]

Promise.all(promises).then(samples => {
    const sample = samples.reduce((x, y) => x.concat(y))
    drawTreemap(convertSample(sample), 1)
})

const preHierarchy= (d) => {
    let data = {}

    data.name = d.data.name
    if (d.children) data.children = d.children.map(c => preHierarchy(c))

    return data
}

const convertSample = (sample) => {
    let data = [{ name: 'root', parent: '' }]

    for (item of sample) {
        const element = item.split('.')
    
        t0 = element[0]
        t1 = t0 + '.' + element[1]
        t2 = t1 + '.' + element[2]
        t3 = item

        if (data.findIndex(i => i.name === t0) === -1) data.push({ name: t0, parent: 'root' })
        if (data.findIndex(i => i.name === t1) === -1) data.push({ name: t1, parent: t0 })
        if (data.findIndex(i => i.name === t2) === -1) data.push({ name: t2, parent: t1 })
        if (data.findIndex(i => i.name === t3) === -1) data.push({ name: t3, parent: t2 })
    }

    const root = d3.stratify()
        .id(function(node) { return node.name; })
        .parentId(function(node) { return node.parent; })
        (data)

    return root.count()
}

const color = d3.scaleOrdinal(d3.schemeCategory10)
const svg = d3.select('#canvas')
    .attr('preserveAspectRatio', 'xMidYMid meet')
    .style('width', '100%')
    .style('height', '100%')

const treemap = () => {
    const canvasWidth = document.getElementById('canvas').clientWidth
    const canvasHeight = document.getElementById('canvas').clientHeight

    svg.attr('viewBox', `0, 0, ${canvasWidth}, ${canvasHeight}`)

    return d3.treemap()
        .size([canvasWidth, canvasHeight])
        .tile(d3.treemapBinary)
        .paddingOuter(5)
        .paddingInner(1)
        .round(true)
}

const drawTreemap = (root) => {
    const canvasWidth = document.getElementById('canvas').clientWidth
    const canvasHeight = document.getElementById('canvas').clientHeight

    const tree = treemap()(root)
    const g = svg.selectAll('g').data(tree.descendants()).enter().append('g')
    const block = g.append('rect')
    
    block.attr('x', d => d.x0)
        .attr('y', d => d.y0)
        .attr('width', d => d.x1 - d.x0)
        .attr('height', d => d.y1 - d.y0)
        .attr('fill', d => {
            return [
                '#FFFFFF',
                color(d.data.name),
                'rgba(255, 255, 255, 0.3)',
                'rgba(255, 255, 255, 0.3)',
                'rgba(255, 255, 255, 0.3)',
            ][d.depth]
        })

    depthManager = new DepthManager(tree)
    
    block.on('click', (b) => {
        g.selectAll('text').remove()
        const target = depthManager.next(b)
        const text = g.append('text').filter((d) => {
            return d.parent && d.parent.id === target.parent.id
        })

        text.attr('x', d => (d.x0 + d.x1) / 2)
            .attr('y', d => (d.y0 + d.y1) / 2)
            .attr('text-anchor', 'middle')
            // .attr('dominant-baseline', 'middle')
            .attr('fill', '#FFFFFF')
            .style('font-size', d => {
                if (d.depth > 3) return `${(d.x1 - d.x0) * 0.05}px`
                else return `${(d.x1 - d.x0) * 0.1}px`
            })
            .text(d => {
                if (d.depth > 3) return d.data.name
                else return d.data.name.split('.').slice(-1)
            })

        svg.transition()
            .duration(1000)
            .attr('viewBox', `${target.x0}, ${target.y0}, ${target.x1 - target.x0}, ${target.y1 - target.y0}`)
    })
}
class DepthManager {
    target = null

    constructor (target) {
        this.target = target
    }

    next (block) {
        const ancestors = block.ancestors().reverse()

        if (block.depth > this.target.depth) {
            this.target = ancestors[this.target.depth + 1]
        } else if (block.depth === this.target.depth) {
            this.target = block
        } else if (block.depth < this.target.depth) {
            this.target = ancestors[block.depth]
        }

        return this.target
    }
}

let depthManager = null